{"version":3,"file":"headroom.min.js","sources":["../src/headroom.js"],"sourcesContent":["/*!\n * headroom.js v0.9.3 - Give your page some headroom. Hide your header until you need it\n * Copyright (c) 2016 Nick Williams - http://wicky.nillia.ms/headroom.js\n * License: MIT\n */\n\n(function(root, factory) {\n    'use strict';\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    }\n    else if (typeof exports === 'object') {\n        // COMMONJS\n        module.exports = factory();\n    }\n    else {\n        // BROWSER\n        root.Headroom = factory();\n    }\n}(this, function() {\n    'use strict';\n\n    /* exported features */\n\n    var features = {\n        bind : !!(function(){}.bind),\n        classList : 'classList' in document.documentElement,\n        rAF : !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame)\n    };\n    window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\n    /**\n     * Handles debouncing of events via requestAnimationFrame\n     * @see http://www.html5rocks.com/en/tutorials/speed/animations/\n     * @param {Function} callback The callback to handle whichever event\n     */\n    function Debouncer (callback) {\n        this.callback = callback;\n        this.ticking = false;\n    }\n    Debouncer.prototype = {\n        constructor : Debouncer,\n\n        /**\n         * dispatches the event to the supplied callback\n         * @private\n         */\n        update : function() {\n            this.callback && this.callback();\n            this.ticking = false;\n        },\n\n        /**\n         * ensures events don't get stacked\n         * @private\n         */\n        requestTick : function() {\n            if(!this.ticking) {\n                requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));\n                this.ticking = true;\n            }\n        },\n\n        /**\n         * Attach this as the event listeners\n         */\n        handleEvent : function() {\n            this.requestTick();\n        }\n    };\n    /**\n     * Check if object is part of the DOM\n     * @constructor\n     * @param {Object} obj element to check\n     */\n    function isDOMElement(obj) {\n        return obj && typeof window !== 'undefined' && (obj === window || obj.nodeType);\n    }\n\n    /**\n     * Helper function for extending objects\n     */\n    function extend (object /*, objectN ... */) {\n        if(arguments.length <= 0) {\n            throw new Error('Missing arguments in extend function');\n        }\n\n        var result = object || {},\n            key,\n            i;\n\n        for (i = 1; i < arguments.length; i++) {\n            var replacement = arguments[i] || {};\n\n            for (key in replacement) {\n                // Recurse into object except if the object is a DOM element\n                if(typeof result[key] === 'object' && ! isDOMElement(result[key])) {\n                    result[key] = extend(result[key], replacement[key]);\n                }\n                else {\n                    result[key] = result[key] || replacement[key];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Helper function for normalizing tolerance option to object format\n     */\n    function normalizeTolerance (t) {\n        return t === Object(t) ? t : { down : t, up : t };\n    }\n\n    /**\n     * UI enhancement for fixed headers.\n     * Hides header when scrolling down\n     * Shows header when scrolling up\n     * @constructor\n     * @param {DOMElement} elem the header element\n     * @param {Object} options options for the widget\n     */\n    function Headroom (elem, options) {\n        options = extend(options, Headroom.options);\n\n        this.lastKnownScrollY = 0;\n        this.elem             = elem;\n        this.tolerance        = normalizeTolerance(options.tolerance);\n        this.classes          = options.classes;\n        this.offset           = options.offset;\n        this.scroller         = options.scroller;\n        this.initialised      = false;\n        this.onPin            = options.onPin;\n        this.onUnpin          = options.onUnpin;\n        this.onTop            = options.onTop;\n        this.onNotTop         = options.onNotTop;\n        this.onBottom         = options.onBottom;\n        this.onNotBottom      = options.onNotBottom;\n    }\n    Headroom.prototype = {\n        constructor : Headroom,\n\n        /**\n         * Initialises the widget\n         */\n        init : function() {\n            if(!Headroom.cutsTheMustard) {\n                return;\n            }\n\n            this.debouncer = new Debouncer(this.update.bind(this));\n            this.elem.classList.add(this.classes.initial);\n\n            // defer event registration to handle browser\n            // potentially restoring previous scroll position\n            setTimeout(this.attachEvent.bind(this), 100);\n\n            return this;\n        },\n\n        /**\n         * Unattaches events and removes any classes that were added\n         */\n        destroy : function() {\n            var classes = this.classes;\n\n            this.initialised = false;\n            this.elem.classList.remove(classes.unpinned, classes.pinned, classes.top, classes.notTop, classes.initial);\n            this.scroller.removeEventListener('scroll', this.debouncer, false);\n        },\n\n        /**\n         * Attaches the scroll event\n         * @private\n         */\n        attachEvent : function() {\n            if(!this.initialised){\n                this.lastKnownScrollY = this.getScrollY();\n                this.initialised = true;\n                this.scroller.addEventListener('scroll', this.debouncer, false);\n\n                this.debouncer.handleEvent();\n            }\n        },\n\n        /**\n         * Unpins the header if it's currently pinned\n         */\n        unpin : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(classList.contains(classes.pinned) || !classList.contains(classes.unpinned)) {\n                classList.add(classes.unpinned);\n                classList.remove(classes.pinned);\n                this.onUnpin && this.onUnpin.call(this);\n            }\n        },\n\n        /**\n         * Pins the header if it's currently unpinned\n         */\n        pin : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(classList.contains(classes.unpinned)) {\n                classList.remove(classes.unpinned);\n                classList.add(classes.pinned);\n                this.onPin && this.onPin.call(this);\n            }\n        },\n\n        /**\n         * Handles the top states\n         */\n        top : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.top)) {\n                classList.add(classes.top);\n                classList.remove(classes.notTop);\n                this.onTop && this.onTop.call(this);\n            }\n        },\n\n        /**\n         * Handles the not top state\n         */\n        notTop : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.notTop)) {\n                classList.add(classes.notTop);\n                classList.remove(classes.top);\n                this.onNotTop && this.onNotTop.call(this);\n            }\n        },\n\n        bottom : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.bottom)) {\n                classList.add(classes.bottom);\n                classList.remove(classes.notBottom);\n                this.onBottom && this.onBottom.call(this);\n            }\n        },\n\n        /**\n         * Handles the not top state\n         */\n        notBottom : function() {\n            var classList = this.elem.classList,\n                classes = this.classes;\n\n            if(!classList.contains(classes.notBottom)) {\n                classList.add(classes.notBottom);\n                classList.remove(classes.bottom);\n                this.onNotBottom && this.onNotBottom.call(this);\n            }\n        },\n\n        /**\n         * Gets the Y scroll position\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY\n         * @return {Number} pixels the page has scrolled along the Y-axis\n         */\n        getScrollY : function() {\n            return (this.scroller.pageYOffset !== undefined)\n                ? this.scroller.pageYOffset\n                : (this.scroller.scrollTop !== undefined)\n                ? this.scroller.scrollTop\n                : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n        },\n\n        /**\n         * Gets the height of the viewport\n         * @see http://andylangton.co.uk/blog/development/get-viewport-size-width-and-height-javascript\n         * @return {int} the height of the viewport in pixels\n         */\n        getViewportHeight : function () {\n            return window.innerHeight\n                || document.documentElement.clientHeight\n                || document.body.clientHeight;\n        },\n\n        /**\n         * Gets the physical height of the DOM element\n         * @param  {Object}  elm the element to calculate the physical height of which\n         * @return {int}     the physical height of the element in pixels\n         */\n        getElementPhysicalHeight : function (elm) {\n            return Math.max(\n                elm.offsetHeight,\n                elm.clientHeight\n            );\n        },\n\n        /**\n         * Gets the physical height of the scroller element\n         * @return {int} the physical height of the scroller element in pixels\n         */\n        getScrollerPhysicalHeight : function () {\n            return (this.scroller === window || this.scroller === document.body)\n                ? this.getViewportHeight()\n                : this.getElementPhysicalHeight(this.scroller);\n        },\n\n        /**\n         * Gets the height of the document\n         * @see http://james.padolsey.com/javascript/get-document-height-cross-browser/\n         * @return {int} the height of the document in pixels\n         */\n        getDocumentHeight : function () {\n            var body = document.body,\n                documentElement = document.documentElement;\n\n            return Math.max(\n                body.scrollHeight, documentElement.scrollHeight,\n                body.offsetHeight, documentElement.offsetHeight,\n                body.clientHeight, documentElement.clientHeight\n            );\n        },\n\n        /**\n         * Gets the height of the DOM element\n         * @param  {Object}  elm the element to calculate the height of which\n         * @return {int}     the height of the element in pixels\n         */\n        getElementHeight : function (elm) {\n            return Math.max(\n                elm.scrollHeight,\n                elm.offsetHeight,\n                elm.clientHeight\n            );\n        },\n\n        /**\n         * Gets the height of the scroller element\n         * @return {int} the height of the scroller element in pixels\n         */\n        getScrollerHeight : function () {\n            return (this.scroller === window || this.scroller === document.body)\n                ? this.getDocumentHeight()\n                : this.getElementHeight(this.scroller);\n        },\n\n        /**\n         * determines if the scroll position is outside of document boundaries\n         * @param  {int}  currentScrollY the current y scroll position\n         * @return {bool} true if out of bounds, false otherwise\n         */\n        isOutOfBounds : function (currentScrollY) {\n            var pastTop  = currentScrollY < 0,\n                pastBottom = currentScrollY + this.getScrollerPhysicalHeight() > this.getScrollerHeight();\n\n            return pastTop || pastBottom;\n        },\n\n        /**\n         * determines if the tolerance has been exceeded\n         * @param  {int} currentScrollY the current scroll y position\n         * @return {bool} true if tolerance exceeded, false otherwise\n         */\n        toleranceExceeded : function (currentScrollY, direction) {\n            return Math.abs(currentScrollY-this.lastKnownScrollY) >= this.tolerance[direction];\n        },\n\n        /**\n         * determine if it is appropriate to unpin\n         * @param  {int} currentScrollY the current y scroll position\n         * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n         * @return {bool} true if should unpin, false otherwise\n         */\n        shouldUnpin : function (currentScrollY, toleranceExceeded) {\n            var scrollingDown = currentScrollY > this.lastKnownScrollY,\n                pastOffset = currentScrollY >= this.offset;\n\n            return scrollingDown && pastOffset && toleranceExceeded;\n        },\n\n        /**\n         * determine if it is appropriate to pin\n         * @param  {int} currentScrollY the current y scroll position\n         * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n         * @return {bool} true if should pin, false otherwise\n         */\n        shouldPin : function (currentScrollY, toleranceExceeded) {\n            var scrollingUp  = currentScrollY < this.lastKnownScrollY,\n                pastOffset = currentScrollY <= this.offset;\n\n            return (scrollingUp && toleranceExceeded) || pastOffset;\n        },\n\n        /**\n         * Handles updating the state of the widget\n         */\n        update : function() {\n            var currentScrollY  = this.getScrollY(),\n                scrollDirection = currentScrollY > this.lastKnownScrollY ? 'down' : 'up',\n                toleranceExceeded = this.toleranceExceeded(currentScrollY, scrollDirection);\n\n            if(this.isOutOfBounds(currentScrollY)) { // Ignore bouncy scrolling in OSX\n                return;\n            }\n\n            if (currentScrollY <= this.offset ) {\n                this.top();\n            } else {\n                this.notTop();\n            }\n\n            if(currentScrollY + this.getViewportHeight() >= this.getScrollerHeight()) {\n                this.bottom();\n            }\n            else {\n                this.notBottom();\n            }\n\n            if(this.shouldUnpin(currentScrollY, toleranceExceeded)) {\n                this.unpin();\n            }\n            else if(this.shouldPin(currentScrollY, toleranceExceeded)) {\n                this.pin();\n            }\n\n            this.lastKnownScrollY = currentScrollY;\n        }\n    };\n    /**\n     * Default options\n     * @type {Object}\n     */\n    Headroom.options = {\n        tolerance : {\n            up : 0,\n            down : 0\n        },\n        offset : 0,\n        scroller: window,\n        classes : {\n            pinned : 'headroom--pinned',\n            unpinned : 'headroom--unpinned',\n            top : 'headroom--top',\n            notTop : 'headroom--not-top',\n            bottom : 'headroom--bottom',\n            notBottom : 'headroom--not-bottom',\n            initial : 'headroom'\n        }\n    };\n    Headroom.cutsTheMustard = typeof features !== 'undefined' && features.rAF && features.bind && features.classList;\n\n    return Headroom;\n}));\n"],"names":["root","factory","this","features","bind","classList","document","documentElement","rAF","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","Debouncer","callback","ticking","isDOMElement","obj","nodeType","extend","object","arguments","length","Error","key","i","result","replacement","Headroom","elem","options","t","lastKnownScrollY","tolerance","Object","down","up","classes","offset","scroller","initialised","onPin","onUnpin","onTop","onNotTop","onBottom","onNotBottom","prototype","constructor","update","requestTick","rafCallback","handleEvent","init","cutsTheMustard","debouncer","add","initial","setTimeout","attachEvent","destroy","remove","unpinned","pinned","top","notTop","removeEventListener","getScrollY","addEventListener","unpin","contains","call","pin","bottom","notBottom","undefined","pageYOffset","scrollTop","body","parentNode","getViewportHeight","innerHeight","clientHeight","getElementPhysicalHeight","elm","Math","max","offsetHeight","getScrollerPhysicalHeight","getDocumentHeight","scrollHeight","getElementHeight","getScrollerHeight","isOutOfBounds","currentScrollY","pastTop","pastBottom","toleranceExceeded","direction","abs","shouldUnpin","scrollingDown","pastOffset","shouldPin","scrollingUp","scrollDirection","define","amd","exports","module"],"mappings":"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"}